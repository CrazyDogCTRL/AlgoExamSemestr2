#include <vector>
#include <cstdint>
#include <functional>
#include <iostream>
#include <algorithm>
#include <limits>
#include <queue>

#define INF std::numeric_limits<int64_t>::max()

struct Edge {
  size_t from;
  size_t to;
  int64_t capacity;
  Edge() : Edge(0, 0, 0) {
  }
  Edge(size_t from, size_t to, int64_t capacity) : from(from), to(to), capacity(capacity) {
  }
};

// Форд-Фалкерсон
class FlowNetwork {
private:
  enum Color { WHITE, GREY, BLACK };
  
public:
    // constructor
  FlowNetwork() {
    size_t n = 0;
    size_t m = 0;
    std::cin >> n >> m >> start >> finish;
    adj_matrix_.resize(n, std::vector<Edge>(n));
    for (size_t i = 0; i < n; ++i) {
      for (size_t j = 0; j < n; ++j) {
        adj_matrix_[i][j].from = i;
        adj_matrix_[i][j].to = j;
      }
    }
    for (size_t i = 0; i < m; ++i) {
      Edge e;
      std::cin >> e.from >> e.to >> e.capacity;
      adj_matrix_[e.from][e.to].capacity = e.capacity;
    }
  }
  
  int64_t MaxFlowFordFulkerson() {
    std::vector<size_t> path(1, start);
    std::vector<Color> colors(adj_matrix_.size(), WHITE);
    int64_t flow;
    int64_t res = 0;
    while (flow = Dfs(path, colors, INF)) {
      for (size_t i = 0; i + 1 < path.size(); ++i) {
        size_t from = path[i];
        size_t to = path[i + 1];
        adj_matrix_[from][to].capacity -= flow;
        adj_matrix_[to][from].capacity += flow;
      }
      path.resize(1);
      colors.assign(adj_matrix_.size(), WHITE);
      res += flow;
    }
    return res;
  }

private:
  int64_t Dfs(std::vector<size_t>& path, std::vector<Color>& colors, int64_t min_flow) {
    const int& v = path.back();
    if (v == finish) {
      return min_flow;
    }
    colors[v] = GREY;
    for (Edge& e : adj_matrix_[v]) {
      if ((colors[e.to] == WHITE) && (e.capacity > 0)) {
        path.emplace_back(e.to);
        if (Dfs(path, colors, std::min(min_flow, e.capacity))) {
          return std::min(min_flow, e.capacity);
        }
        path.pop_back();
      }
    }
    colors[v] = BLACK;
    return 0;
  }
  
  std::vector<std::vector<Edge>> adj_matrix_;
  size_t start;
  size_t finish;
};

// Асимптотика O(F*E), где F - макс поток

// Эдмонс-Карп

/*
class FlowNetwork {
private:
  enum Color { WHITE, GREY, BLACK };
  
public:
    // constructor
  FlowNetwork() {
    size_t n = 0;
    size_t m = 0;
    std::cin >> n >> m >> start >> finish;
    adj_matrix_.resize(n, std::vector<Edge>(n));
    for (size_t i = 0; i < n; ++i) {
      for (size_t j = 0; j < n; ++j) {
        adj_matrix_[i][j].from = i;
        adj_matrix_[i][j].to = j;
      }
    }
    
    for (size_t i = 0; i < m; ++i) {
      Edge e;
      std::cin >> e.from >> e.to >> e.capacity;
      adj_matrix_[e.from][e.to].capacity = e.capacity;
    }
  }
  
  int64_t MaxFlowEdmondsKarp() {
    std::vector<size_t> path(1, start);
    int64_t flow;
    int64_t res = 0;
    while (flow = Bfs(path)) {
      for (size_t i = 0; i + 1 < path.size(); ++i) {
        size_t from = path[i];
        size_t to = path[i + 1];
        adj_matrix_[from][to].capacity -= flow;
        adj_matrix_[to][from].capacity += flow;
      }
      path.resize(1);
      res += flow;
    }
    return res;
  }
  
private:
  int64_t Bfs(std::vector<size_t>& path) {
    std::queue<size_t> bfs_queue;
    std::vector<size_t> parents(adj_matrix_.size(), INF);
    bfs_queue.emplace(path.back());
    std::vector<size_t> dists(adj_matrix_.size(), INF);
    dists[bfs_queue.front()] = 0;
    while (!bfs_queue.empty()) {
      size_t v = bfs_queue.front();
      bfs_queue.pop();
      for (size_t i = 0; i < adj_matrix_.size(); ++i) {
        if (adj_matrix_[v][i].capacity > 0 && dists[i] > dists[v] + 1) {
          dists[i] = dists[v] + 1;
          bfs_queue.push(i);
          parents[i] = v;
        }
      }
    }
    if (dists[finish] == INF) {
      return 0;
    }
    path.clear();
    path.emplace_back(finish);
    size_t v = finish;
    int64_t res = INF;
    while (v != start) {
      path.push_back(parents[v]);
      res = std::min(res, adj_matrix_[parents[v]][v].capacity);
      v = parents[v];
    }
    std::reverse(path.begin(), path.end());
    return res;
  }
  
  std::vector<std::vector<Edge>> adj_matrix_;
  size_t start;
  size_t finish;
};
*/
// Асимптотика O(VE^2)
